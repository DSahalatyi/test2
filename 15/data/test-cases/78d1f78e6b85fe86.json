{"uid":"78d1f78e6b85fe86","name":"test_attempt_delete_food_section_with_random_token","fullName":"tests.food_section_api.test_food_section_delete#test_attempt_delete_food_section_with_random_token","historyId":"fb694134e9dabfe4563034e807bf3178","time":{"start":1677527513704,"stop":1677527513704,"duration":0},"status":"broken","statusMessage":"httpx.ConnectError: [Errno 111] Connection refused","statusTrace":"map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_exceptions.py:10: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.backends.sync.SyncBackend object at 0x7f2abc3a0a90>\nhost = 'localhost', port = 5000, timeout = 5.0, local_address = None\n\n    def connect_tcp(\n        self,\n        host: str,\n        port: int,\n        timeout: typing.Optional[float] = None,\n        local_address: typing.Optional[str] = None,\n    ) -> NetworkStream:\n        address = (host, port)\n        source_address = None if local_address is None else (local_address, 0)\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n        with map_exceptions(exc_map):\n>           sock = socket.create_connection(\n                address, timeout, source_address=source_address\n            )\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/backends/sync.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('localhost', 5000), timeout = 5.0, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None, *, all_errors=False):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default. When a connection\n        cannot be created, raises the last error if *all_errors* is False,\n        and an ExceptionGroup of all errors if *all_errors* is True.\n        \"\"\"\n    \n        host, port = address\n        exceptions = []\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                exceptions.clear()\n                return sock\n    \n            except error as exc:\n                if not all_errors:\n                    exceptions.clear()  # raise only the last error\n                exceptions.append(exc)\n                if sock is not None:\n                    sock.close()\n    \n        if len(exceptions):\n            try:\n                if not all_errors:\n>                   raise exceptions[0]\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/socket.py:851: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('localhost', 5000), timeout = 5.0, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None, *, all_errors=False):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default. When a connection\n        cannot be created, raises the last error if *all_errors* is False,\n        and an ExceptionGroup of all errors if *all_errors* is True.\n        \"\"\"\n    \n        host, port = address\n        exceptions = []\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/socket.py:836: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.HTTPTransport object at 0x7f2abc3a0b50>\nrequest = <Request('POST', 'http://localhost:5000/api/auth/register')>\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n    \n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n>           resp = self._pool.handle_request(req)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:218: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.ConnectionPool object at 0x7f2abc3a0bd0>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        status = RequestStatus(request)\n    \n        with self._pool_lock:\n            self._requests.append(status)\n            self._close_expired_connections()\n            self._attempt_to_acquire_connection(status)\n    \n        while True:\n            timeouts = request.extensions.get(\"timeout\", {})\n            timeout = timeouts.get(\"pool\", None)\n            try:\n                connection = status.wait_for_connection(timeout=timeout)\n            except BaseException as exc:\n                # If we timeout here, or if the task is cancelled, then make\n                # sure to remove the request from the queue before bubbling\n                # up the exception.\n                with self._pool_lock:\n                    self._requests.remove(status)\n                    raise exc\n    \n            try:\n                response = connection.handle_request(request)\n            except ConnectionNotAvailable:\n                # The ConnectionNotAvailable exception is a special case, that\n                # indicates we need to retry the request on a new connection.\n                #\n                # The most common case where this can occur is when multiple\n                # requests are queued waiting for a single connection, which\n                # might end up as an HTTP/2 connection, but which actually ends\n                # up as HTTP/1.1.\n                with self._pool_lock:\n                    # Maintain our position in the request queue, but reset the\n                    # status so that the request becomes queued again.\n                    status.unset_connection()\n                    self._attempt_to_acquire_connection(status)\n            except BaseException as exc:\n                self.response_closed(status)\n>               raise exc\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:253: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.ConnectionPool object at 0x7f2abc3a0bd0>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        status = RequestStatus(request)\n    \n        with self._pool_lock:\n            self._requests.append(status)\n            self._close_expired_connections()\n            self._attempt_to_acquire_connection(status)\n    \n        while True:\n            timeouts = request.extensions.get(\"timeout\", {})\n            timeout = timeouts.get(\"pool\", None)\n            try:\n                connection = status.wait_for_connection(timeout=timeout)\n            except BaseException as exc:\n                # If we timeout here, or if the task is cancelled, then make\n                # sure to remove the request from the queue before bubbling\n                # up the exception.\n                with self._pool_lock:\n                    self._requests.remove(status)\n                    raise exc\n    \n            try:\n>               response = connection.handle_request(request)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:237: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        with self._request_lock:\n            if self._connection is None:\n                try:\n                    stream = self._connect(request)\n    \n                    ssl_object = stream.get_extra_info(\"ssl_object\")\n                    http2_negotiated = (\n                        ssl_object is not None\n                        and ssl_object.selected_alpn_protocol() == \"h2\"\n                    )\n                    if http2_negotiated or (self._http2 and not self._http1):\n                        from .http2 import HTTP2Connection\n    \n                        self._connection = HTTP2Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                    else:\n                        self._connection = HTTP11Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                except Exception as exc:\n                    self._connect_failed = True\n>                   raise exc\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        with self._request_lock:\n            if self._connection is None:\n                try:\n>                   stream = self._connect(request)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection.py:63: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def _connect(self, request: Request) -> NetworkStream:\n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"connect\", None)\n    \n        retries_left = self._retries\n        delays = exponential_backoff(factor=RETRIES_BACKOFF_FACTOR)\n    \n        while True:\n            try:\n                if self._uds is None:\n                    kwargs = {\n                        \"host\": self._origin.host.decode(\"ascii\"),\n                        \"port\": self._origin.port,\n                        \"local_address\": self._local_address,\n                        \"timeout\": timeout,\n                    }\n                    with Trace(\n                        \"connection.connect_tcp\", request, kwargs\n                    ) as trace:\n>                       stream = self._network_backend.connect_tcp(**kwargs)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.backends.sync.SyncBackend object at 0x7f2abc3a0a90>\nhost = 'localhost', port = 5000, timeout = 5.0, local_address = None\n\n    def connect_tcp(\n        self,\n        host: str,\n        port: int,\n        timeout: typing.Optional[float] = None,\n        local_address: typing.Optional[str] = None,\n    ) -> NetworkStream:\n        address = (host, port)\n        source_address = None if local_address is None else (local_address, 0)\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n>       with map_exceptions(exc_map):\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/backends/sync.py:93: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7f2abc3a20d0>\ntyp = <class 'ConnectionRefusedError'>\nvalue = ConnectionRefusedError(111, 'Connection refused')\ntraceback = <traceback object at 0x7f2abc3a2480>\n\n    def __exit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n>               self.gen.throw(typ, value, traceback)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmap = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE786\n            for from_exc, to_exc in map.items():\n                if isinstance(exc, from_exc):\n>                   raise to_exc(exc)\nE                   httpcore.ConnectError: [Errno 111] Connection refused\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError\n\nThe above exception was the direct cause of the following exception:\n\nclient = <httpx.Client object at 0x7f2abc3a0410>\ntest_user_info = {'age': 20, 'email': 'test_email@g.com', 'first_name': 'Test', 'is_staff': True, ...}\n\n    @pytest.fixture(scope=\"function\")\n    def register_test_user(client, test_user_info):\n>       yield client.post('api/auth/register', data=test_user_info)\n\ntests/conftest.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:1136: in post\n    return self.request(\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:821: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:908: in send\n    response = self._send_handling_auth(\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:936: in _send_handling_auth\n    response = self._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:973: in _send_handling_redirects\n    response = self._send_single_request(request)\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:1009: in _send_single_request\n    response = transport.handle_request(request)\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:217: in handle_request\n    with map_httpcore_exceptions():\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py:155: in __exit__\n    self.gen.throw(typ, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE-786\n            mapped_exc = None\n    \n            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():\n                if not isinstance(exc, from_exc):\n                    continue\n                # We want to map to the most specific exception we can find.\n                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to\n                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.\n                if mapped_exc is None or issubclass(to_exc, mapped_exc):\n                    mapped_exc = to_exc\n    \n            if mapped_exc is None:  # pragma: no cover\n                raise\n    \n            message = str(exc)\n>           raise mapped_exc(message) from exc\nE           httpx.ConnectError: [Errno 111] Connection refused\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:77: ConnectError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"client","time":{"start":1677527513704,"stop":1677527513775,"duration":71},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"test_user_info","time":{"start":1677527513775,"stop":1677527513775,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"register_test_user","time":{"start":1677527513775,"stop":1677527513776,"duration":1},"status":"broken","statusMessage":"httpx.ConnectError: [Errno 111] Connection refused\n","statusTrace":"  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 39, in _multicall\n    res = hook_impl.function(*args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/_pytest/fixtures.py\", line 1129, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/_pytest/fixtures.py\", line 901, in call_fixture_func\n    fixture_result = next(generator)\n                     ^^^^^^^^^^^^^^^\n  File \"/home/runner/work/test2/test2/tests/conftest.py\", line 71, in register_test_user\n    yield client.post('api/auth/register', data=test_user_info)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 1136, in post\n    return self.request(\n           ^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 821, in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 908, in send\n    response = self._send_handling_auth(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 936, in _send_handling_auth\n    response = self._send_handling_redirects(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 973, in _send_handling_redirects\n    response = self._send_single_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 1009, in _send_single_request\n    response = transport.handle_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py\", line 217, in handle_request\n    with map_httpcore_exceptions():\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py\", line 155, in __exit__\n    self.gen.throw(typ, value, traceback)\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py\", line 77, in map_httpcore_exceptions\n    raise mapped_exc(message) from exc\n","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":true,"hasContent":true},{"name":"db_utility","time":{"start":1677527514591,"stop":1677527514594,"duration":3},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"register_random_user","time":{"start":1677527514594,"stop":1677527514595,"duration":1},"status":"broken","statusMessage":"httpx.ConnectError: [Errno 111] Connection refused\n","statusTrace":"  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 39, in _multicall\n    res = hook_impl.function(*args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/_pytest/fixtures.py\", line 1129, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/_pytest/fixtures.py\", line 901, in call_fixture_func\n    fixture_result = next(generator)\n                     ^^^^^^^^^^^^^^^\n  File \"/home/runner/work/test2/test2/tests/conftest.py\", line 76, in register_random_user\n    yield client.post('api/auth/register', json=random_user_info)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 1136, in post\n    return self.request(\n           ^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 821, in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 908, in send\n    response = self._send_handling_auth(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 936, in _send_handling_auth\n    response = self._send_handling_redirects(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 973, in _send_handling_redirects\n    response = self._send_single_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 1009, in _send_single_request\n    response = transport.handle_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py\", line 217, in handle_request\n    with map_httpcore_exceptions():\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py\", line 155, in __exit__\n    self.gen.throw(typ, value, traceback)\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py\", line 77, in map_httpcore_exceptions\n    raise mapped_exc(message) from exc\n","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":true,"hasContent":true},{"name":"random_user_info","time":{"start":1677527514594,"stop":1677527514594,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false}],"afterStages":[{"name":"test_user_info::0","time":{"start":1677527513921,"stop":1677527513921,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"client::0","time":{"start":1677527514048,"stop":1677527514048,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"db_utility::0","time":{"start":1677527514719,"stop":1677527514722,"duration":3},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"random_user_info::0","time":{"start":1677527514719,"stop":1677527514719,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false}],"labels":[{"name":"tag","value":"@pytest.mark.usefixtures('create_test_food_section')"},{"name":"tag","value":"tcid70"},{"name":"tag","value":"food_section_delete"},{"name":"parentSuite","value":"tests.food_section_api"},{"name":"suite","value":"test_food_section_delete"},{"name":"host","value":"fv-az361-125"},{"name":"thread","value":"2849-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.food_section_api.test_food_section_delete"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":["tcid70","@pytest.mark.usefixtures('create_test_food_section')","food_section_delete"]},"source":"78d1f78e6b85fe86.json","parameterValues":[]}