{"uid":"d51fa56dc0cf6322","name":"test_attempt_update_food_item_with_empty_price","fullName":"tests.food_item_api.test_food_item_update#test_attempt_update_food_item_with_empty_price","historyId":"08e2d68e8236aedd59d6bc5fdc6957e8","time":{"start":1677527503170,"stop":1677527503170,"duration":0},"status":"broken","statusMessage":"httpx.ReadError: [Errno 104] Connection reset by peer","statusTrace":"map = {<class 'TimeoutError'>: <class 'httpcore.ReadTimeout'>, <class 'OSError'>: <class 'httpcore.ReadError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_exceptions.py:10: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.backends.sync.SyncStream object at 0x7f911253e510>\nmax_bytes = 65536, timeout = 5.0\n\n    def read(self, max_bytes: int, timeout: typing.Optional[float] = None) -> bytes:\n        exc_map: ExceptionMapping = {socket.timeout: ReadTimeout, OSError: ReadError}\n        with map_exceptions(exc_map):\n            self._sock.settimeout(timeout)\n>           return self._sock.recv(max_bytes)\nE           ConnectionResetError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/backends/sync.py:28: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpx.HTTPTransport object at 0x7f91125e9e50>\nrequest = <Request('POST', 'http://localhost:5000/api/auth/register')>\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n    \n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n>           resp = self._pool.handle_request(req)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:218: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.ConnectionPool object at 0x7f91125e9850>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        status = RequestStatus(request)\n    \n        with self._pool_lock:\n            self._requests.append(status)\n            self._close_expired_connections()\n            self._attempt_to_acquire_connection(status)\n    \n        while True:\n            timeouts = request.extensions.get(\"timeout\", {})\n            timeout = timeouts.get(\"pool\", None)\n            try:\n                connection = status.wait_for_connection(timeout=timeout)\n            except BaseException as exc:\n                # If we timeout here, or if the task is cancelled, then make\n                # sure to remove the request from the queue before bubbling\n                # up the exception.\n                with self._pool_lock:\n                    self._requests.remove(status)\n                    raise exc\n    \n            try:\n                response = connection.handle_request(request)\n            except ConnectionNotAvailable:\n                # The ConnectionNotAvailable exception is a special case, that\n                # indicates we need to retry the request on a new connection.\n                #\n                # The most common case where this can occur is when multiple\n                # requests are queued waiting for a single connection, which\n                # might end up as an HTTP/2 connection, but which actually ends\n                # up as HTTP/1.1.\n                with self._pool_lock:\n                    # Maintain our position in the request queue, but reset the\n                    # status so that the request becomes queued again.\n                    status.unset_connection()\n                    self._attempt_to_acquire_connection(status)\n            except BaseException as exc:\n                self.response_closed(status)\n>               raise exc\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:253: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.ConnectionPool object at 0x7f91125e9850>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        status = RequestStatus(request)\n    \n        with self._pool_lock:\n            self._requests.append(status)\n            self._close_expired_connections()\n            self._attempt_to_acquire_connection(status)\n    \n        while True:\n            timeouts = request.extensions.get(\"timeout\", {})\n            timeout = timeouts.get(\"pool\", None)\n            try:\n                connection = status.wait_for_connection(timeout=timeout)\n            except BaseException as exc:\n                # If we timeout here, or if the task is cancelled, then make\n                # sure to remove the request from the queue before bubbling\n                # up the exception.\n                with self._pool_lock:\n                    self._requests.remove(status)\n                    raise exc\n    \n            try:\n>               response = connection.handle_request(request)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:237: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection ['http://localhost:5000', HTTP/1.1, CLOSED, Request Count: 17]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        with self._request_lock:\n            if self._connection is None:\n                try:\n                    stream = self._connect(request)\n    \n                    ssl_object = stream.get_extra_info(\"ssl_object\")\n                    http2_negotiated = (\n                        ssl_object is not None\n                        and ssl_object.selected_alpn_protocol() == \"h2\"\n                    )\n                    if http2_negotiated or (self._http2 and not self._http1):\n                        from .http2 import HTTP2Connection\n    \n                        self._connection = HTTP2Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                    else:\n                        self._connection = HTTP11Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                except Exception as exc:\n                    self._connect_failed = True\n                    raise exc\n            elif not self._connection.is_available():\n                raise ConnectionNotAvailable()\n    \n>       return self._connection.handle_request(request)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/connection.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTP11Connection ['http://localhost:5000', CLOSED, Request Count: 17]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection \"\n                f\"to {self._origin}\"\n            )\n    \n        with self._state_lock:\n            if self._state in (HTTPConnectionState.NEW, HTTPConnectionState.IDLE):\n                self._request_count += 1\n                self._state = HTTPConnectionState.ACTIVE\n                self._expire_at = None\n            else:\n                raise ConnectionNotAvailable()\n    \n        try:\n            kwargs = {\"request\": request}\n            with Trace(\"http11.send_request_headers\", request, kwargs) as trace:\n                self._send_request_headers(**kwargs)\n            with Trace(\"http11.send_request_body\", request, kwargs) as trace:\n                self._send_request_body(**kwargs)\n            with Trace(\n                \"http11.receive_response_headers\", request, kwargs\n            ) as trace:\n                (\n                    http_version,\n                    status,\n                    reason_phrase,\n                    headers,\n                ) = self._receive_response_headers(**kwargs)\n                trace.return_value = (\n                    http_version,\n                    status,\n                    reason_phrase,\n                    headers,\n                )\n    \n            return Response(\n                status=status,\n                headers=headers,\n                content=HTTP11ConnectionByteStream(self, request),\n                extensions={\n                    \"http_version\": http_version,\n                    \"reason_phrase\": reason_phrase,\n                    \"network_stream\": self._network_stream,\n                },\n            )\n        except BaseException as exc:\n            with Trace(\"http11.response_closed\", request) as trace:\n                self._response_closed()\n>           raise exc\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/http11.py:112: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTP11Connection ['http://localhost:5000', CLOSED, Request Count: 17]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection \"\n                f\"to {self._origin}\"\n            )\n    \n        with self._state_lock:\n            if self._state in (HTTPConnectionState.NEW, HTTPConnectionState.IDLE):\n                self._request_count += 1\n                self._state = HTTPConnectionState.ACTIVE\n                self._expire_at = None\n            else:\n                raise ConnectionNotAvailable()\n    \n        try:\n            kwargs = {\"request\": request}\n            with Trace(\"http11.send_request_headers\", request, kwargs) as trace:\n                self._send_request_headers(**kwargs)\n            with Trace(\"http11.send_request_body\", request, kwargs) as trace:\n                self._send_request_body(**kwargs)\n            with Trace(\n                \"http11.receive_response_headers\", request, kwargs\n            ) as trace:\n                (\n                    http_version,\n                    status,\n                    reason_phrase,\n                    headers,\n>               ) = self._receive_response_headers(**kwargs)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/http11.py:91: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTP11Connection ['http://localhost:5000', CLOSED, Request Count: 17]>\nrequest = <Request [b'POST']>\n\n    def _receive_response_headers(\n        self, request: Request\n    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]]]:\n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"read\", None)\n    \n        while True:\n>           event = self._receive_event(timeout=timeout)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/http11.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTP11Connection ['http://localhost:5000', CLOSED, Request Count: 17]>\ntimeout = 5.0\n\n    def _receive_event(\n        self, timeout: Optional[float] = None\n    ) -> Union[h11.Event, Type[h11.PAUSED]]:\n        while True:\n            with map_exceptions({h11.RemoteProtocolError: RemoteProtocolError}):\n                event = self._h11_state.next_event()\n    \n            if event is h11.NEED_DATA:\n>               data = self._network_stream.read(\n                    self.READ_NUM_BYTES, timeout=timeout\n                )\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_sync/http11.py:191: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.backends.sync.SyncStream object at 0x7f911253e510>\nmax_bytes = 65536, timeout = 5.0\n\n    def read(self, max_bytes: int, timeout: typing.Optional[float] = None) -> bytes:\n        exc_map: ExceptionMapping = {socket.timeout: ReadTimeout, OSError: ReadError}\n>       with map_exceptions(exc_map):\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/backends/sync.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7f91126fe6d0>\ntyp = <class 'ConnectionResetError'>\nvalue = ConnectionResetError(104, 'Connection reset by peer')\ntraceback = <traceback object at 0x7f91126ffbc0>\n\n    def __exit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n>               self.gen.throw(typ, value, traceback)\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmap = {<class 'TimeoutError'>: <class 'httpcore.ReadTimeout'>, <class 'OSError'>: <class 'httpcore.ReadError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE786\n            for from_exc, to_exc in map.items():\n                if isinstance(exc, from_exc):\n>                   raise to_exc(exc)\nE                   httpcore.ReadError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ReadError\n\nThe above exception was the direct cause of the following exception:\n\nclient = <httpx.Client object at 0x7f91126f0f10>\ntest_user_info = {'age': 20, 'email': 'test_email@g.com', 'first_name': 'Test', 'is_staff': True, ...}\n\n    @pytest.fixture(scope=\"function\")\n    def register_test_user(client, test_user_info):\n>       yield client.post('api/auth/register', data=test_user_info)\n\ntests/conftest.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:1136: in post\n    return self.request(\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:821: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:908: in send\n    response = self._send_handling_auth(\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:936: in _send_handling_auth\n    response = self._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:973: in _send_handling_redirects\n    response = self._send_single_request(request)\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py:1009: in _send_single_request\n    response = transport.handle_request(request)\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:217: in handle_request\n    with map_httpcore_exceptions():\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py:155: in __exit__\n    self.gen.throw(typ, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE-786\n            mapped_exc = None\n    \n            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():\n                if not isinstance(exc, from_exc):\n                    continue\n                # We want to map to the most specific exception we can find.\n                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to\n                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.\n                if mapped_exc is None or issubclass(to_exc, mapped_exc):\n                    mapped_exc = to_exc\n    \n            if mapped_exc is None:  # pragma: no cover\n                raise\n    \n            message = str(exc)\n>           raise mapped_exc(message) from exc\nE           httpx.ReadError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py:77: ReadError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"client","time":{"start":1677527500802,"stop":1677527500874,"duration":72},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"register_test_user","time":{"start":1677527503171,"stop":1677527503174,"duration":3},"status":"broken","statusMessage":"httpx.ReadError: [Errno 104] Connection reset by peer\n","statusTrace":"  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 39, in _multicall\n    res = hook_impl.function(*args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/_pytest/fixtures.py\", line 1129, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/_pytest/fixtures.py\", line 901, in call_fixture_func\n    fixture_result = next(generator)\n                     ^^^^^^^^^^^^^^^\n  File \"/home/runner/work/test2/test2/tests/conftest.py\", line 71, in register_test_user\n    yield client.post('api/auth/register', data=test_user_info)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 1136, in post\n    return self.request(\n           ^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 821, in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 908, in send\n    response = self._send_handling_auth(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 936, in _send_handling_auth\n    response = self._send_handling_redirects(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 973, in _send_handling_redirects\n    response = self._send_single_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_client.py\", line 1009, in _send_single_request\n    response = transport.handle_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py\", line 217, in handle_request\n    with map_httpcore_exceptions():\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/contextlib.py\", line 155, in __exit__\n    self.gen.throw(typ, value, traceback)\n  File \"/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/site-packages/httpx/_transports/default.py\", line 77, in map_httpcore_exceptions\n    raise mapped_exc(message) from exc\n","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":true,"hasContent":true},{"name":"test_user_info","time":{"start":1677527503171,"stop":1677527503171,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"db_utility","time":{"start":1677527505536,"stop":1677527505539,"duration":3},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false}],"afterStages":[{"name":"test_user_info::0","time":{"start":1677527503306,"stop":1677527503306,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"client::0","time":{"start":1677527503468,"stop":1677527503468,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"db_utility::0","time":{"start":1677527505671,"stop":1677527505674,"duration":3},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false}],"labels":[{"name":"tag","value":"@pytest.mark.usefixtures('create_test_food_item')"},{"name":"tag","value":"tcid87"},{"name":"tag","value":"food_item_update"},{"name":"parentSuite","value":"tests.food_item_api"},{"name":"suite","value":"test_food_item_update"},{"name":"host","value":"fv-az359-565"},{"name":"thread","value":"2898-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.food_item_api.test_food_item_update"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":["@pytest.mark.usefixtures('create_test_food_item')","tcid87","food_item_update"]},"source":"d51fa56dc0cf6322.json","parameterValues":[]}